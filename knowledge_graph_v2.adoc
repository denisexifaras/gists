= Building a Knowledge Graph

anchor:anchor-2[]

anchor:anchor-2[]


== Big Picture Motivation

==== Internal Use

create a reference database of "knowledge" that will map out the themes in digital enlightenment. This is interesting in its own right, for example in order to allow to modularise content for the day course or workshops. An extensive topic database can be used as a reference for creating "bespoke" courses, or for extending/modifying "standard" courses.

==== For an online course

We would like to build an online learning platform with the following attributes:
[loweralpha]
. it will contain all topics for digital enlightenment
. the set of topics that a user will explore will depend on who the user is
. the delivery method (learning experience) will adjust to who the user is

anchor:anchor-2[]

anchor:anchor-2[]

== So, creating a Knowledge Graph...

=== What is a graph?

//hide
[source,cypher]
----

CREATE

(ct:Thing {name:"Comp. Thinking", description:"This is the philosophy behind programming.",importance:10}),
(data:Thing {name:"Data", description:"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."}),
(web:Thing {name:"Web", description:"Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt."}),
(web)-[:r]->(data),
(data)-[:r]->(ct),
(ct)-[:r]->(web),


(html:Thing {name:"html"}),
(html)-[:r]->(web),
(web)-[:r]->(html),
(js:Thing {name:"JavaScript"}),
(js)-[:r]->(web),
(js)-[:r]->(ct),
(web)-[:r]->(js),
(ct)-[:r]->(js),

(python:Thing {name:"Python",type:"Skill"}),
(python)-[:r]->(data),
(python)-[:r]->(ct),
(ct)-[:r]->(python),
(data)-[:r]->(python),

(cloud:Thing {name:"Cloud",type:"Object"}),
(cloud)-[:r]->(data),
(cloud)-[:r]->(web),
(data)-[:r]->(cloud),
(web)-[:r]->(cloud);

MATCH (n)-[:r]->(b) CREATE UNIQUE (b)-[:r]->(n);
MATCH (n) RETURN n;

----

//graph

[source,cypher]
----

MATCH (a)
WHERE HAS(a.description)
RETURN a.name AS NAME, a.description AS DESCRIPTION;

----

//table

anchor:anchor-2[]


=== Why use one here?

//list
. Intuitive way to think of relationships between topics

anchor:anchor-2[]

. Completely flexbile to accommodate nested relationships

anchor:anchor-2[]

. Allows us to explore/visualise more distant relationships

anchor:anchor-2[]

. Lots of graph theory to help us create ``sensible'' journeys

anchor:anchor-2[]

=== Tools

*Neo4j* ``The world's leading Graph Database''
  
  We don't have to use a graph database. We can use document stores and use graph thoery externally. And we will to some extent. But it's still useful: allows us to store properties etc all in one place. Among other things, it will also hold pointers to the actual document stores.
  (so it's more a database of databases)

anchor:anchor-2[]

*Cypher* Graph query language used with Neo4j. 

  If we stick with Neo4j everyone will need to learn cypher...?
  
  As above, it's possible cypher will only be used for basic queries to get some initial output from the database and then a programming language will take over.

=== What have we collected?

==== Nodes

>300 topics by looking through all our presentations, table of contents from online books and brainstorming

  Obviously this is not exhaustive but was not meant to be (There are tons of things that I have not included here (for example consider ToC from http://shop.oreilly.com/product/9780596805531.do)) (will revisit this in a sec)!
  
  A node should be anything that we envisage will hold data (information/slides/exercises).
  
//hidden
[source,cypher]
----
//Clear all
MATCH (n)-[r]->() DELETE n,r;
MATCH (n) DELETE n;

CREATE

(ct:Thing {name:"Comp. Thinking", description:"This is the philosophy behind programming.",importance:10}),
(data:Thing {name:"Data", description:"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."}),
(web:Thing {name:"Web", description:"Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt."}),
(html:Thing {name:"html"}),
(js:Thing {name:"JavaScript"}),
(python:Thing {name:"Python",type:"Skill"}),
(cloud:Thing {name:"Cloud",type:"Object"});

MATCH (n) RETURN n;

----
//graph

==== Edges
  
>1500 connections between them: we create ‘links’ between nodes that are related in a very obvious way.
  
  NOTE: Edges are are added only if two nodes are related in a very obvious way (for example Google Fusion has not been linked to anything). Obviously the more edges the more flexbile the journey through the graph can be, but this has to balance with a sensible number of possible journeys and journey architecture. For example, Google Doc -> Data Store but Google Doc !-> Data. This highlights the importance of looking further away then 1st degree relationships whenever we are exploring the graph.
  
  At this stage, edges are bidirectional and carry equal weight. This will eventually have to be revised...

  *The process of adding edges should be supervised by more than one person....*

//hidden
[source,cypher]
----

//Clear all
MATCH (n)-[r]->() DELETE n,r;
MATCH (n) DELETE n;

CREATE

(ct:Thing {name:"Comp. Thinking", description:"This is the philosophy behind programming.",importance:10}),
(data:Thing {name:"Data", description:"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."}),
(web:Thing {name:"Web", description:"Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt."}),
(web)-[:r]->(data),
(data)-[:r]->(ct),
(ct)-[:r]->(web),


(html:Thing {name:"html"}),
(html)-[:r]->(web),
(web)-[:r]->(html),
(js:Thing {name:"JavaScript"}),
(js)-[:r]->(web),
(js)-[:r]->(ct),
(web)-[:r]->(js),
(ct)-[:r]->(js),

(python:Thing {name:"Python",type:"Skill"}),
(python)-[:r]->(data),
(python)-[:r]->(ct),
(ct)-[:r]->(python),
(data)-[:r]->(python),

(cloud:Thing {name:"Cloud",type:"Object"}),
(cloud)-[:r]->(data),
(cloud)-[:r]->(web),
(data)-[:r]->(cloud),
(web)-[:r]->(cloud);

MATCH (n)-[:r]->(b) CREATE UNIQUE (b)-[:r]->(n);
MATCH (n) RETURN n;

----
//graph

==== Where?

All scripts are uploaded on my decoded google drive. We should discuss moving that to a decoded github folder. 

== Hierarchy

=== What are the categories?

== The Graph

=== Summary Stats

=== Category contents

=== Examples

== What is this Graph?

== Next Steps

== Also...






